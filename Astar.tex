\osprey 3.0's code has been heavily optimized to improve single-threaded performance relative to the previous version, \osprey 2.2~\cite{COMETS}. Two main areas have received the most attention and the most improvement in performance so far: \as search speed, and conformation minimization speed.

\osprey uses the \as search algorithm~\cite{DEE/A*} to perform its combinatorial search over sequence and conformational space~\cite{minDEE,iMinDEE,DEEPer}.  The performance of \as search in \osprey depends mostly on the size of the conformation space of the design: the time required for search scales strongly with the number of mutable and flexible residues. Search time is also dependent on the speed at which we can evaluate the energy scoring functions on \as nodes. Optimizations in \osprey 3.0 have dramatically increased the \as node scoring speed, mainly by caching the results of expensive computations and reusing them at different nodes. Many intermediate values used by the \as scoring functions need only be computed once per design. This reduces the cost of node scoring by roughly an order of magnitude. We can also score child nodes differentially against their parent nodes to speed up node scoring. Caching intermediate values during the parent node scoring and using them to simplify child node scoring yields roughly another order of magnitude speedup in \as node scoring. %\jeff{trying to be concise here, hopefully we don't need the mathematical details of these \as scoring functions?}

\osprey 3.0 also includes optimizations to improve the performance of forcefield evaluation and conformation minimization. Conformation minimization is typically the bottleneck in \osprey calculations with continuous flexibility~\cite{minDEE,iMinDEE,DEEPer,CATS}.  The code in \osprey 3.0 that evaluates forcefield energies for a protein conformation has been heavily optimized, although speed gains here over \osprey2 are modest (roughly two-fold), since the original code was already well-optimized in this area. Much larger performance increases were gained by caching forcefield parameters and lists of atom pairs between different conformations to be minimized, which yielded roughly a 10-fold increase in speed. \osprey 3.0 also increases performance by only evaluating forcefield terms involving mutable and/or flexible residues in a design, since interaction energies between other residues will be identical across all sequences and conformations.  Since most designs only model a minority of the residues in a protein as flexible, this can be a substantial improvement. 

Performance comparisons are shown for 45 protein design test cases in Fig.~\ref{fig:2v3} and Table~\ref{table:2v3}.  All these test cases model continuous protein flexibility~\cite{minDEE,iMinDEE,EPIC}, and 18 of them involve provably accurate partition function calculations (see Table~\ref{table:2v3} and Ref.~\citen{EPIC} for details).  To summarize, the optimizations to single-threaded performance described above made \osprey 3.0 on average 461-fold faster than \osprey 2.2 across 29 protein design test cases, and allowed \osprey 3.0 to finish the remaining 16 test cases, which \osprey 2.2 could not finish within a 17-day time limit.  For example, \osprey 2.2 on a Intel Xeon E5-2640 v4 CPU took 49.5 minutes to run a small (6 continuously flexible residues) benchmark sidechain packing problem involving a 114-residue fragment of PDZ3 domain of PSD-95 protein complexed with a 6-residue peptide ligand (PDB ID: 1TP5).  But \osprey 3.0 finished the same design in 7.0 seconds on the same hardware, which is a 424-fold speedup.  

