\def\as{\textit{$A^*$}\xspace}
\def\ks{\textit{$K^*$}\xspace}
\def\ka{\textit{$K_a$}\xspace}
\def\bbks{\textit{BBK$^*$}\xspace}
\def\multisequencebound{MS\xspace}
\def\msbound{\multisequencebound}


\def\submissionMode{0}

\newcommand{\cut}[1]{}

\subsection{\bbks: Efficiently computing the tightest binding sequences from a combinatorially large number of binding partners}
\jj{This was an attempt to describe \ks. It's more of a placeholder to show the tone and points I think we should get across.}
Although many GMEC-based designs predict sequences which fold and even bind the desired target, proteins do not exist in nature as a single static structure, but instead as thermodynamic ensemble of structures. Protein design algorithms that optimize binding affinity search for sequences whose thermodynamic ensemble energetically favor the desired bound or unbound states over other undesirable states. In doing so, these algorithms search for sequences whose conformational ensemble may contain multiple low-energy conformations in the desired state. Algorithms whose input model accounts for the ensemble-nature of proteins more accurately represent protein flexibility, and can identify sequences with multiple low-energy conformations which GMEC-based algorithms would overlook.
The \ks algorithm~\cite{} models an ensemble of Boltzmann-weighted conformations to approximate the Boltzmann-weighted partition function $Z$. It combines dead-end elimination pruning~\cite{} with \as~\cite{} gap-free conformation enumeration to compute provable $\varepsilon$-approximations $Z$ for the protein states of interest. \ks combines these $Z$ scores to approximate the association constant, \ka, as the ratio of $\varepsilon$-approximate partition functions between the bound and unbound states of a protein-ligand complex. Notably, each partition function ratio, called a \ks \emph{score}, is provably accurate with respect to the the biophysical \emph{input model}~\cite{}. \jj{I suspect an explanation of the input model belongs elsewhere in this paper. It wouldn't make sense to introduce it after describing LUTE, etc. I'm keeping it in the source file so we can move it where it needs to go.}\cut{The input model defines the set of allowed amino acid mutations (i.e.~the \emph{sequence space}), structural search space (i.e.~the input structures, and allowed protein flexibility), the optimization objective (e.g.~design for binding affinity), and the energy function~\cite{}.} \ks efficiently approximates \ka by provably enumerating a gap-free list of low-energy conformations without exploring infrequently observed high-energy conformations in the protein or ligand. By doing so \ks is considerably more efficient than exhaustive conformation enumeration, enumerating as little as 3\% of the space of all possible conformations for a given sequence.
Notably, \ks is able to efficiently search over conformations for a \textit{single sequence}. A long-standing area for potential improvement has therefore been to develop algorithms that efficiently search over \textit{multiple sequences}. All provable ensemble-based algorithms, as well as many heuristic algorithms which optimize binding affinity, are \emph{single-sequence} algorithms, which must compute or bound the binding affinity for each possible sequence. The asymptotic runtime complexity of single-sequence algorithms is therefore linear in the number of possible sequences, and exponential in the number of mutable residues. Therefore, designs with many mutable residues rapidly become intractable when using single-sequence algorithms. To manage the combinatorial explosion of the sequence space, \ks uses its inter-mutation pruning filter to prune sequences whose \ks scores provably cannot be within a user-specified factor of the best sequence encountered thus far. Nevertheless, inter-mutation pruning is applied only \emph{after} \ks initiates binding affinity computation, meaning that \ks must compute the \ks score for each possible sequence.

\osprey 3 provides a new algorithm, \bbks, which overcomes this challenge. \bbks~\cite{BBK*} builds on \ks, and is the first provable, ensemble-based protein design algorithm to run in time sublinear in the number of sequences. The key innovation in \bbks that enables this improvement is the \emph{multi-sequence bound} (\msbound). Rather than compute binding affinity separately for each possible sequence, as single-sequence methods do, \bbks efficiently computes a single provable \ks score upper bound for a combinatorial number of sequences. \bbks uses \msbound bounds to prune a combinatorial number of sequences during the search, entirely avoiding single-sequence computation for all pruned sequences. Indeed, this combinatorial pruning produces a significant empirical runtime speedup: \bbks runs in time sub-linear in the number of sequences. In our experiments, \bbks provably computed the tightest binding sequences while computing \ks scores for up to 10$^5$ fewer sequences than any single-sequence algorithm.

Importantly, \bbks also contains many other powerful algorithmic improvements and implementation optimizations: the parallel architecture of \bbks, which enables concurrent energy minimization, and a novel two-pass partition function bound, which minimizes far fewer conformations while still computing a provable $\varepsilon$-approximation to the partition function. Combined with the combinatorial pruning power of the \msbound bound, \bbks is able to search over sequence spaces [X] orders of magnitude larger than previously possible with single-sequence \ks. Not only is \bbks able to provably bound and prune a combinatorial number of suboptimal sequences, \bbks also provably approximates \ks scores for individual sequences [Y] times faster than single-sequence \ks.