\def\as{\textit{$A^*$}\xspace}
\def\ks{\textit{$K^*$}\xspace}
\def\ka{\textit{$K_a$}\xspace}
\def\bbks{\textit{BBK$^*$}\xspace}
\def\multisequencebound{MS\xspace}
\def\msbound{\multisequencebound}

\subsection{\bbks: Efficiently computing the tightest binding sequences from a combinatorially large number of binding partners}

The \ks algorithm~\cite{}, which uses dead-end elimination pruning~\cite{} followed by \as~\cite{} gap-free conformation enumeration to provably approximate the association constant, \ka, as the ratio of $\varepsilon$-approximate partition functions between the bound and unbound states of a protein-ligand complex. Importantly, each partition function ratio, called a \ks \emph{score}, is provably accurate to the the biophysical \emph{input model}~\cite{}. The input model defines the set of allowed amino acid mutations (i.e.~the \emph{sequence space}), structural search space (i.e.~the input structures, and allowed protein flexibility), the optimization objective (e.g.~design for binding affinity), and the energy function~\cite{}. \ks efficiently approximates \ka by using provable guarantees to compute the ensemble of most probable, low-energy conformations and discard higher energy, rarely populated conformations in the protein or ligand. Although \ks is considerably more efficient than exhaustive conformation enumeration for all possible sequences, \ks and all previous provable ensemble-based algorithms~\cite{} are \emph{single-sequence} algorithms, which explicitly consider every allowed sequence. The empirical and asymptotic runtime complexity of single-sequence algorithms is linear in the number of possible sequences, and therefore exponential in the number of mutable residues. As the number of mutable residues increases, the number of possible sequences increases exponentially. Therefore, designs with many mutable residues rapidly become intractable when using single-sequence algorithms. To manage the combinatorial explosion of the sequence space, \ks uses its inter-mutation pruning filter to prune sequences whose \ks scores provably cannot be within a user-specified factor of the best sequence encountered thus far. Nevertheless, inter-mutation pruning is applied only \emph{after} \ks initiates binding affinity computation, meaning that \ks must explicitly consider every possible sequence.

\bbks~\cite{BBK*} improves on \ks in two ways. First, \bbks computes $\varepsilon$-approximations to partition functions up to 1982-fold more quickly than \ks. This speed improvement is due to a combination of improvements over \ks: the parallel architecture of \bbks, which enables concurrent energy minimization, and a novel two-pass partition function bound, which requires that fewer conformations be energy minimized in order to compute a $\varepsilon$-approximation to the partition function. Second, \bbks can compute the tightest binding sequences from a combinatorially large space of possible sequences without explicitly initiating or computing binding affinity for the remaining, provably sub-optimal sequences. The key innovation in \bbks that enables this improvement is the \emph{multi-sequence bound} (\msbound). Rather than compute binding affinity separately for each possible sequence, as single-sequence methods do, \bbks efficiently computes a single provable \ks score upper bound for a combinatorial number of sequences. \bbks uses \msbound bounds to prune a combinatorial number of sequences during the search, entirely avoiding single-sequence computation for all pruned sequences. Indeed, this combinatorial pruning produces a significant empirical runtime speedup: \bbks runs in time sub-linear in the number of sequences. In our experiments, \bbks provably computed the tightest binding sequences while computing \ks scores for up to 10$^5$ fewer sequences than any single-sequence algorithm.